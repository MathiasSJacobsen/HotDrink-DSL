/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export interface Arguments extends AstNode {
    readonly $container: Method;
    final: Array<Reference<Variable>>
    ref: Array<Reference<Variable>>
}

export const Arguments = 'Arguments';

export function isArguments(item: unknown): item is Arguments {
    return reflection.isInstance(item, Arguments);
}

export interface Body extends AstNode {
    value: ImpFunction | Expr
}

export const Body = 'Body';

export function isBody(item: unknown): item is Body {
    return reflection.isInstance(item, Body);
}

export interface BoolConst extends AstNode {
    value: 'true' | 'false'
}

export const BoolConst = 'BoolConst';

export function isBoolConst(item: unknown): item is BoolConst {
    return reflection.isInstance(item, BoolConst);
}

export interface Component extends AstNode {
    readonly $container: Model;
    constraints: Array<Constraint>
    name: string
    vars: Array<Variable>
}

export const Component = 'Component';

export function isComponent(item: unknown): item is Component {
    return reflection.isInstance(item, Component);
}

export interface Constraint extends AstNode {
    readonly $container: Component;
    methods: Array<Method>
    name: string
}

export const Constraint = 'Constraint';

export function isConstraint(item: unknown): item is Constraint {
    return reflection.isInstance(item, Constraint);
}

export interface Expr extends AstNode {
    readonly $container: Body | Not | MulOrDiv | PlusOrMinus | Comparison | Equality | And | Or;
}

export const Expr = 'Expr';

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr);
}

export interface ImpFunction extends AstNode {
    readonly $container: Body;
    args: Array<Reference<Variable>>
    name: string
}

export const ImpFunction = 'ImpFunction';

export function isImpFunction(item: unknown): item is ImpFunction {
    return reflection.isInstance(item, ImpFunction);
}

export interface Import extends AstNode {
    readonly $container: Model;
    file: string
    funcs: Array<string>
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface IntConst extends AstNode {
    value: number
}

export const IntConst = 'IntConst';

export function isIntConst(item: unknown): item is IntConst {
    return reflection.isInstance(item, IntConst);
}

export interface Method extends AstNode {
    readonly $container: Constraint;
    args: Arguments
    name: string
}

export const Method = 'Method';

export function isMethod(item: unknown): item is Method {
    return reflection.isInstance(item, Method);
}

export interface Model extends AstNode {
    component: Array<Component>
    imports: Array<Import>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface StringConst extends AstNode {
    value: string
}

export const StringConst = 'StringConst';

export function isStringConst(item: unknown): item is StringConst {
    return reflection.isInstance(item, StringConst);
}

export interface Variable extends AstNode {
    readonly $container: Component;
    name: string
}

export const Variable = 'Variable';

export function isVariable(item: unknown): item is Variable {
    return reflection.isInstance(item, Variable);
}

export interface VarRef extends AstNode {
    value: Reference<Variable>
}

export const VarRef = 'VarRef';

export function isVarRef(item: unknown): item is VarRef {
    return reflection.isInstance(item, VarRef);
}

export interface And extends Expr {
    left: Expr
    op: '&&'
    right: Expr
}

export const And = 'And';

export function isAnd(item: unknown): item is And {
    return reflection.isInstance(item, And);
}

export interface Comparison extends Expr {
    left: Expr
    op: '>=' | '<=' | '>' | '<'
    right: Expr
}

export const Comparison = 'Comparison';

export function isComparison(item: unknown): item is Comparison {
    return reflection.isInstance(item, Comparison);
}

export interface Equality extends Expr {
    left: Expr
    op: '==' | '!=' | '===' | '!=='
    right: Expr
}

export const Equality = 'Equality';

export function isEquality(item: unknown): item is Equality {
    return reflection.isInstance(item, Equality);
}

export interface MulOrDiv extends Expr {
    left: Expr
    op: '*' | '/'
    right: Expr
}

export const MulOrDiv = 'MulOrDiv';

export function isMulOrDiv(item: unknown): item is MulOrDiv {
    return reflection.isInstance(item, MulOrDiv);
}

export interface Not extends Expr {
    expression: Expr
}

export const Not = 'Not';

export function isNot(item: unknown): item is Not {
    return reflection.isInstance(item, Not);
}

export interface Or extends Expr {
    left: Expr
    right: Expr
}

export const Or = 'Or';

export function isOr(item: unknown): item is Or {
    return reflection.isInstance(item, Or);
}

export interface PlusOrMinus extends Expr {
    left: Expr
    op: '+' | '-'
    right: Expr
}

export const PlusOrMinus = 'PlusOrMinus';

export function isPlusOrMinus(item: unknown): item is PlusOrMinus {
    return reflection.isInstance(item, PlusOrMinus);
}

export interface Var extends Variable {
}

export const Var = 'Var';

export function isVar(item: unknown): item is Var {
    return reflection.isInstance(item, Var);
}

export type HotDrinkDslAstType = 'Arguments' | 'Body' | 'BoolConst' | 'Component' | 'Constraint' | 'Expr' | 'ImpFunction' | 'Import' | 'IntConst' | 'Method' | 'Model' | 'StringConst' | 'Variable' | 'VarRef' | 'And' | 'Comparison' | 'Equality' | 'MulOrDiv' | 'Not' | 'Or' | 'PlusOrMinus' | 'Var';

export type HotDrinkDslAstReference = 'Arguments:final' | 'Arguments:ref' | 'ImpFunction:args' | 'VarRef:value';

export class HotDrinkDslAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['Arguments', 'Body', 'BoolConst', 'Component', 'Constraint', 'Expr', 'ImpFunction', 'Import', 'IntConst', 'Method', 'Model', 'StringConst', 'Variable', 'VarRef', 'And', 'Comparison', 'Equality', 'MulOrDiv', 'Not', 'Or', 'PlusOrMinus', 'Var'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case And:
            case Comparison:
            case Equality:
            case MulOrDiv:
            case Not:
            case Or:
            case PlusOrMinus: {
                return this.isSubtype(Expr, supertype);
            }
            case Var: {
                return this.isSubtype(Variable, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: HotDrinkDslAstReference): string {
        switch (referenceId) {
            case 'Arguments:final': {
                return Variable;
            }
            case 'Arguments:ref': {
                return Variable;
            }
            case 'ImpFunction:args': {
                return Variable;
            }
            case 'VarRef:value': {
                return Variable;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new HotDrinkDslAstReflection();
